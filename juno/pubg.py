# -*- coding: utf-8 -*-
"""Pubg.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qunaMGTZTba3NJqAGh-hKxxq8Quuk4RO

# Load Data
"""

import pandas as pd
import numpy as np

train = pd.read_csv('C:/Users/sundooedu/Desktop/pubg-finish-placement-prediction/train_V2.csv')

train['matchType'].unique()

train_solo = train[train['matchType']=='solo']
train_duo = train[train['matchType']=='duo']
train_squad = train[train['matchType']=='squad']
d = train[train['matchType']=='solo-fpp']
e = train[train['matchType']=='duo-fpp']
f = train[train['matchType']=='squad-fpp']

train_solo = pd.concat([train_solo,d],axis=0)
train_duo = pd.concat([train_duo,e],axis=0)
train_squad = pd.concat([train_squad,f],axis=0)

"""- DBNOs - Number of enemy players knocked.
- headshotKills - Number of enemy players killed with headshots.
- killPlace - Ranking in match of number of enemy players killed.
- killPoints - Kills-based external ranking of player. (Think of this as an Elo ranking where only kills matter.)
- kills - Number of enemy players killed.
- killStreaks - Max number of enemy players killed in a short amount of time.
- longestKill - Longest distance between player and player killed at time of - death. This may be misleading, as downing a - player and driving away may lead to a large longestKill stat.
- rideDistance - Total distance traveled in vehicles measured in meters.
- teamKills - Number of times this player killed a teammate.
- walkDistance - Total distance traveled on foot measured in meters.
- winPoints - Win-based external ranking of player. (Think of this as an Elo - ranking where only winning matters.)
- winPlacePerc - The target of prediction. This is a percentile winning placement, where 1 corresponds to 1st place, and 0 corresponds to last place in the match. It is calculated off of maxPlace, not numGroups, so it is possible to have missing chunks in a match.
"""

train_squad

train_squad.columns

train_squad

#train_solo.to_csv('train_solo.csv',header=False)
# train_duo.to_csv('train_duo.csv',header=False)
# train_squad.to_csv('train_squad.csv')

"""## 독립변수 설명

- groupId - Integer ID to identify a group within a match. If the same group of players plays in different matches, they will have a different groupId each time.
- matchId - Integer ID to identify match. There are no matches that are in both the training and testing set.
-  assists - Number of enemy players this player damaged that were killed by teammates.
- boosts - Number of boost items used.
- damageDealt - Total damage dealt. Note: Self inflicted damage is subtracted.
- DBNOs - Number of enemy players knocked.
headshotKills - Number of enemy players killed with headshots.
- heals - Number of healing items used.
- killPlace - Ranking in match of number of enemy players killed.
- killPoints - Kills-based external ranking of player. (Think of this as an Elo ranking where only kills matter.)
- kills - Number of enemy players killed.
- killStreaks - Max number of enemy players killed in a short amount of time.
- longestKill - Longest distance between player and player killed at time of death. This may be misleading, as downing a - player and driving away may lead to a large longestKill stat.
- maxPlace - Worst placement we have data for in the match. This may not match with numGroups, as sometimes the data skips over placements.
- numGroups - Number of groups we have data for in the match.
revives - Number of times this player revived teammates.
- rideDistance - Total distance traveled in vehicles measured in meters.
- roadKills - Number of kills while in a vehicle.
- swimDistance - Total distance traveled by swimming measured in meters.
teamKills - Number of times this player killed a teammate.
- vehicleDestroys - Number of vehicles destroyed.
- walkDistance - Total distance traveled on foot measured in meters.
- weaponsAcquired - Number of weapons picked up.
- winPoints - Win-based external ranking of player. (Think of this as an Elo ranking where only winning matters.)
- winPlacePerc - The target of prediction. This is a percentile winning placement, where 1 corresponds to 1st place, and 0 corresponds to last place in the match. It is calculated off of maxPlace, not numGroups, so it is possible to have missing chunks in a match.

# Use jamovi

- jamovi로 독립변수들의 관계가 유의한지 확인한다.



![image.png](attachment:image.png)

## squad

- DBNOs - Number of enemy players knocked.
- headshotKills - Number of enemy players killed with headshots.
- killPlace - Ranking in match of number of enemy players killed.
- killPoints - Kills-based external ranking of player. (Think of this as an Elo ranking where only kills matter.)
- kills - Number of enemy players killed.
- killStreaks - Max number of enemy players killed in a short amount of time.
- longestKill - Longest distance between player and player killed at time of - death. This may be misleading, as downing a - player and driving away may lead to a large longestKill stat.
- rideDistance - Total distance traveled in vehicles measured in meters.
- teamKills - Number of times this player killed a teammate.
- walkDistance - Total distance traveled on foot measured in meters.
- winPoints - Win-based external ranking of player. (Think of this as an Elo - ranking where only winning matters.)
- winPlacePerc - The target of prediction. This is a percentile winning placement, where 1 corresponds to 1st place, and 0 corresponds to last place in the match. It is calculated off of maxPlace, not numGroups, so it is possible to have missing chunks in a match.
"""

train_squad

train_squad.columns

"""# 표본화"""

from sklearn.model_selection import train_test_split


x=train_squad.drop(['Id','groupId','matchId','matchType','assists','boosts','heals','killPoints','matchDuration','matchType'\
                 ,'maxPlace','numGroups','rankPoints','revives','rideDistance','roadKills','swimDistance','vehicleDestroys'\
                 ,'walkDistance','weaponsAcquired','winPoints','winPlacePerc'],axis=1)
y = train_squad['longestKill']
x_test,x_train,y_test,y_train = train_test_split(x,y,test_size = 0.3,random_state=0)

test1 =x_train

# x_test2,x_train2,y_test2,y_train2 = train_test_split(train_squad.drop(['Id','groupId','matchId','matchType'],axis=1),train_squad['longestKill'],test_size = 0.2)

# test2 =x_train2

x_train = x_train[['killPlace','kills','killStreaks','longestKill','headshotKills'\
           ,'damageDealt','teamKills','DBNOs']]

test1

x_train

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
x_train = scaler.fit_transform(x_train)
x_test = scaler.fit_transform(x_test)

test1.reset_index(drop=True,inplace=True)
#test2.reset_index(drop=True,inplace=True)

test1

"""- jamovi에서 돌려보기 위해 추출"""

#test1.to_csv("squad_test1_0.1.csv")
#test2.to_csv("squad_test2_0.2.csv")

"""- KMeans"""

x =test1[['kills','killPlace','killStreaks']]
x

import matplotlib.pylab as plt
from sklearn.cluster import KMeans
distortions = []
for i in range(1,5):
    kmeans =KMeans(n_clusters=i,n_init=10,max_iter=300) #Elbow Method
    kmeans.fit(x)
    distortions.append(kmeans.inertia_)
plt.plot(range(1,5),distortions,marker='o')
plt.show

"""- silhouette"""

kmeans = KMeans(n_clusters = 3, max_iter=100) #silhouette
y_pred = kmeans.fit_predict(x)
from sklearn.metrics import silhouette_samples, silhouette_score
silhouette_score(x,labels=kmeans.labels_)

kmeans.cluster_centers_

"""- 종속변수 추출"""

y = kmeans.labels_

kmeans = KMeans(n_clusters = 2, max_iter=300) #silhouette
y_pred = kmeans.fit_predict(x)
from sklearn.metrics import silhouette_samples, silhouette_score
silhouette_score(x,labels=kmeans.labels_)

kmeans.cluster_centers_

y2=kmeans.labels_

y2

y=pd.DataFrame(y)

result_squad_1 = pd.concat([x,y],axis=1)
result_squad_1.columns=['kills','killPlace','killStreaks','target']

result_squad_1.info()

result_squad_1.describe(include='all')

squad0=result_squad_1[result_squad_1['target']==0]

squad1=result_squad_1[result_squad_1['target']==1]

squad2=result_squad_1[result_squad_1['target']==2]

squad0.describe()

squad1.describe()

squad2.describe()

import seaborn as sns
sns.pairplot(result_squad_1,diag_kind='kde',hue="target",palette='bright')
plt.show()

"""# 사용할 독립변수로 데이터가공"""

test1.columns

x = test1[['killPlace','kills','killStreaks','longestKill','headshotKills'\
           ,'damageDealt','teamKills','DBNOs']]

x_1 =x_train
x_1

"""# Scaling"""

# from sklearn.preprocessing import StandardScaler
# scaler = StandardScaler()
# x_1 = scaler.fit_transform(x_1)

import matplotlib.pylab as plt
from sklearn.cluster import KMeans
distortions = []
for i in range(1,5):
    kmeans =KMeans(n_clusters=i,n_init=10,max_iter=100) #Elbow Method
    kmeans.fit(x_1)
    distortions.append(kmeans.inertia_)
plt.plot(range(1,5),distortions,marker='o')
plt.show

kmeans.cluster_centers_

kmeans = KMeans(n_clusters = 2, max_iter=100) 
y_pred = kmeans.fit_predict(x_1)

# from sklearn.metrics import silhouette_samples, silhouette_score
# silhouette_score(x_1,labels=kmeans.labels_)

kmeans.labels_

y_1_1=kmeans.labels_
y_1_1=pd.DataFrame(y_1_1)
result_squad_1 = pd.concat([x,y_1_1],axis=1)

result_squad_1

result_squad_1.columns = ['killPlace','kills','killStreaks','longestKill','headshotKills',\
                          'damageDealt','teamKills','DBNOs','target']

result_squad_1

squad0_0=result_squad_1[result_squad_1['target']==0]
squad0_1=result_squad_1[result_squad_1['target']==1]

squad0_0

squad0_1

squad0_0.describe() # 잘함

squad0_1.describe() #못함

import seaborn as sns
sns.pairplot(result_squad_1,palette='bright')
plt.show()

"""# 회귀분석

- test data load
"""

test = pd.read_csv('C:/Users/sundooedu/Desktop/test_data_cheatUser.csv')

"""## VotingClassifier

- DecisionTree
- LogisticRegression
- RandomForest
"""

X = result_squad_1[['killPlace','kills','killStreaks',\
                        'longestKill','headshotKills','damageDealt','teamKills','DBNOs']]
y = result_squad_1['target']

X_train,X_test,y_train,y_test = train_test_split(X,y,random_state=77)

"""- 스케일링"""

scaler = StandardScaler()
X_test = scaler.fit_transform(X_test)
X_train = scaler.fit_transform(X_train)

from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import VotingClassifier,RandomForestClassifier
from sklearn.naive_bayes import GaussianNB

clflog = LogisticRegression(random_state=1)
clfdt = DecisionTreeClassifier(random_state=1)
clfrf = RandomForestClassifier()
clfgnb = GaussianNB()

eclf_h =VotingClassifier(estimators = [('log',clflog),('dt',clfdt),('rf',clfrf),('gnb',clfgnb)],voting='hard')
eclf_s =VotingClassifier(estimators = [('log',clflog),('dt',clfdt),('rf',clfrf),('gnb',clfgnb)],voting='soft')
models = [clflog,clfdt,clfrf,clfgnb,eclf_h,eclf_s]

from sklearn.metrics import classification_report

for model in models:
  model.fit(X_train,y_train)  
  predictions = model.predict(X_test)
  print(classification_report(y_test,predictions))

from sklearn.metrics import confusion_matrix

models_ = [clflog,clfdt,clfrf,clfgnb]
for model in models_:
  pred = model.predict(X_test)
  print(confusion_matrix(y_test,pred))

"""## GridSearchCV"""

eclf_h1 = VotingClassifier(estimators = [('log',clflog), ('dt',clfdt),('rf',clfrf)],voting='hard')
c_params = [0.001, 0, 0.01, 0.1, 1.0, 10.0, 100.0]
params = {
  'log__solver':['saga'],
  'log__penalty':['l2'],
  'log__C':c_params,  
  'rf__n_estimators':[100,1000],
  'rf__criterion':['entropy'],
  'rf__max_depth':[10,8,7,6,5,4,3,2]
 }
from sklearn.model_selection import GridSearchCV
grid = GridSearchCV(estimator = eclf_h1, param_grid=params, cv=5)
grid = grid.fit(X_train,y_train)
grid.best_params_

test.columns

test

"""# predict_use_testdata"""

result =model.predict(test)
result = pd.DataFrame(result)
result.columns = ['target']

total=pd.concat([test,result],axis=1)

total.describe()

total

total[total['target']==1].describe()

total[total['target']==0].describe()

model.predict([[6,8,2,85.3215,0,201.321,0,6]])



